---
layout:

title: 0-面向对象设计原则

date: 2016-10-05

updated: 2016-10-05

tags:
- 设计模式
- UML与设计模式

categories: 设计模式

permalink:

thumbnail:

toc: true

comment: true

notag: false

top: false

---


# 0-面向对象设计原则

## 0.1 单一职责原则

### 0.1.1 单一职责原则定义

- 单一职责原则：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。
- 就一个类而言，应该仅有一个引起它变化的原因

### 0.1.2 单一职责原则分析 

- 一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小
- 当一个职责变化时，可能会影响其他职责的运作
- 将这些职责进行分离，将不同的职责封装在不同的类中
- 将不同的变化原因封装在不同的类中
- 单一职责原则是实现高内聚、低耦合的指导方针

### 0.1.3 单一职责原则实例

![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-1-3-1.png)
![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-1-3-2.png)


## 0.2 开闭原则

### 0.2.1 开闭原则定义

- 开闭原则：软件实体应当对扩展开放，对修改关闭。

### 0.2.2 开闭原则实例

![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-2-2-1.png)

### 0.2.3 开闭原则分析 
- 抽象化是开闭原则的关键
- 相对稳定的抽象层 + 灵活的具体层
- 对可变性封装原则(Principle of Encapsulation of Variation, EVP)：找到系统的可变因素并将其封装起来

## 0.3 里氏代换原则

### 0.3.1 里氏代换原则定义

- 里氏代换原则：所有引用基类的地方必须能透明地使用其子类的对象。

### 0.3.2 里氏代换原则分析

- 在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象
- 在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型
- 里氏代换原则是实现开闭原则的重要方式之一
- Java、C#等面向对象语言中，在编译阶段，编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。

## 0.4 依赖倒转原则

### 0.4.1 依赖倒转原则定义

- 依赖倒转原则：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。
- 要针对接口编程，不要针对实现编程

### 0.4.2 依赖倒转原则分析
- 在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等
- 在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中
- 针对抽象层编程，将具体类的对象通过依赖注入(Dependency Injection, DI)的方式注入到其他对象
    - 构造注入
    - 设值注入（Setter注入）
    - 接口注入

### 0.4.3 依赖倒转原则示例

![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-4-3-1.png)

![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-4-3-2.png)


- 在大多数情况下，这三个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致


## 0.5 接口隔离原则

### 0.5.1 接口隔离原则定义

- 接口隔离原则：客户端不应该依赖那些它不需要的接口。

### 0.5.2 接口隔离原则分析 

- 当一个接口太大时，需要将它分割成一些更细小的接口
- 使用该接口的客户端仅需知道与之相关的方法即可
- 每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干
- 一个类型所提供的所有方法特征的集合。一个接口代表一个角色，每个角色都有它特定的一个接口，“角色隔离原则”
- 狭义的特定语言的接口。接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口，每个接口中只包含一个客户端所需的方法，“定制服务”

### 0.5.3 接口隔离原则示例

![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-5-3-1.png)
![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-5-3-2.png)

## 0.6 合成复用原则

## 0.6.1 合成复用原则定义

- 合成复用原则：优先使用对象组合，而不是继承来达到复用的目的。

## 0.6.2 合成复用原则分析

- 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分
- 新对象通过委派调用已有对象的方法达到复用功能的目的
- 复用时要尽量使用组合/聚合关系（关联关系），少用继承
- 继承复用：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（“白箱”复用 ）
- 组合/聚合复用：耦合度相对较低，有选择性地调用成员对象的操作；可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。（“黑箱”复用 ）



## 0.6.3 合成复用原则示例

![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-6-1-1.png)
![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-6-1-2.png)

- CustomerDAO和DBUtil之间的关系由继承关系变为关联关系，采用依赖注入的方式将DBUtil对象注入到CustomerDAO中，可以使用构造注入，也可以使用Setter注入。如果需要对DBUtil的功能进行扩展，可以通过其子类来实现，如通过子类OracleDBUtil来连接Oracle数据库。
- 由于CustomerDAO针对DBUtil编程，根据里氏代换原则，DBUtil子类的对象可以覆盖DBUtil对象，只需在CustomerDAO中注入子类对象即可使用子类所扩展的方法。
- 例如在CustomerDAO中注入OracleDBUtil对象，即可实现Oracle数据库连接，原有代码无须进行修改，而且还可以很灵活地增加新的数据库连接方式。

## 0.7 迪米特法则

## 0.7.1 迪米特法则定义

- 迪米特法则：每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。




## 0.7.2 迪米特法则分析

- 迪米特法则要求一个软件实体应当尽可能少地与其他实体发生相互作用
- 应用迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系
- 迪米特法则要求在设计系统时，应该尽量减少对象之间的交互
- 如果两个对象之间不必彼此直接通信，那么这两个对象就不应该发生任何直接的相互作用
- 如果其中一个对象需要调用另一个对象的方法，可以通过“第三者”转发这个调用
- 通过引入一个合理的“第三者”来降低现有对象之间的耦合度


## 0.7.3 迪米特法则

![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-7-3-1.png)
![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-7-3-2.png)
![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-7-3-3.png)
![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-7-3-3.png)


































